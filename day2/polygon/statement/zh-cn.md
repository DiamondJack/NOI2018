{{ self.title() }}

{{ s('description') }}

九条可怜是一个喜欢出题的女孩子。

在今年的 World Final 结束以后，可怜特别喜欢计算几何，于是她打算在 NOI 的考场上也出一个计算几何：这是一道只有题目名字和计算几何相关的题目。

首先，可怜给出了一棵 $n(n \geq 2)$ 个节点的有根树 $T$，根节点为 $1$。定义叶子节点为除了根以外所有度数恰好为 $1$ 的节点。下图是一个树 $T$ 的例子，其中叶子节点集合为 $\{3,4,5\}$。

{{ img('1.png', size = 0.6, align = 'middle', inline = False) }}

接着通过这棵树，可怜构造了一个序列 $A$:

- 从根节点开始深度优先遍历整棵树，遍历时按照编号从小到大的顺序来访问孩子，这样可以得到一个树 $T$ 的 DFS 序 $a$。
- 接着按照在 DFS 序中的出现顺序从前往后，可怜把所有叶子节点排成一排得到了一个序列 $A$。

更进一步地，通过序列 $A$，可怜定义了两个叶子节点 $u,v$ 的距离 $d(u,v)$：假设 $u$ 在 $A$ 中是第 $i$ 个元素，$v$ 是第 $j$ 个元素，则 $d(u,v)=\min(|i-j|, |A|-|i-j|)$。其中 $|A|$ 为序列的长度，即 $T$ 的叶子个数。

最后，可怜给出了一个参数 $K$，利用这棵有根树 $T$ 和序列$A$，我们可以构造一张 $n$ 个点的无重边的无向图 $G$：两个点 $(u,v)$ 之间右边当且仅当它们满足下列条件中的至少一个：

- 在 $T$ 中存在连接 $u,v$ 的边。
- 在 $T$ 中 $u,v$ 都是叶子节点且 $d(u,v) \leq K$。

现在可怜想让你来计算一下 $G$ 中不同的哈密尔顿回路数量有多少条，答案可能很大，请对 $998244353$ 取模后输出。

下面是一些补充定义：

- 无向图 $G$ 的一条哈密尔顿回路 $H$ 是 $G$ 中边的一个子集，其中每一个点恰好有两条不同的相邻边在 $H$ 中，且任意两个点都可以通过 $H$ 中的边直接或间接到达。
- 无向图 $G$ 的两条哈密尔顿回路 $H_1,H_2$ 是不同的当且仅当存在一条边 $e$ 使得 $e$ 在 $H_1$ 中且不在 $H_2$ 中。

{{ s('input format') }}

{{ self.input_file() }}

第一行输入两个整数 $n,K$，表示树 $T$ 的点数以及可怜选定的参数 $K$。

第二行输入 $n-1$ 个整数 $f_i(1 \leq f_i <i)$，其中 $f_i$ 表示树 $T$ 上存在边 $(f_i,i)$。

{{ s('output format') }}

{{ self.output_file() }}

输出一行一个整数，表示哈密尔顿回路数量对 $998244353$ 取模后的结果。

{{ s('sample', 1) }}

{{ self.sample_text() }}


{{ self.title_sample_description() }}

{{ s('sample', 2) }}

{{ self.sample_text() }}

{{ self.title_sample_description() }}

{{ s('sample', 3) }}

{{ self.sample_file() }}

{{ s('subtasks') }}

各测试点的数据规模和性质如下表：

{{ tbl('data') }}

表格中的特殊性质如下：

- 特殊性质 S：保证 $T\le 10$；

- 特殊性质 A：保证 $a_i = b_i - 1$；

- 特殊性质 B：保证 $c_i = 0$；

- 特殊性质 C：对于任意 $i,j$，保证 $x_i$ 到 $y_i$ 的最小字典序的最短路径所经过的编号最小的路口不同于 $x_j$ 到 $y_j$ 的最小字典序的最短路径所经过的编号最小的路口；

- 特殊性质 D：对于任意 $i$，保证 $x_i$ 到 $y_i$ 的最小字典序的最短路径所经过的编号最小的路口为路口 $1$。

注意测试点中的 $T$ 可能会很大，**请控制初始化的复杂度，避免每次清空整个数组**，如使用 `memset(a, 0, sizeof(a))` 或 `fillchar(a, sizeof(a), 0)`。

对于所有的数据，$n\le {{ tl.hn(prob.args['maxn'])  }}, m\le {{ tl.hn(prob.args['maxm'])  }}, c_i\le 10^9, v_i\le 10^9n$。每个测试点中，所有 $n$ 的和不会超过 ${{ tl.hn(20 * prob.args['maxn'])  }}$，所有 $m$ 的和不会超过 ${{ tl.hn(20 * prob.args['maxm'])  }}$，并且 $n\ge 10^3,m\ge 2\times 10^3$ 的数据不会超过 $10$ 组。