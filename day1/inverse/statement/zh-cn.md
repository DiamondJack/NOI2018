{{ self.title() }}

{{ s('background') }}

Shimpme 是一位热爱思考，喜欢大开脑洞的同学，对很多算法问题问题都有自己独到的见解。遗憾的是，喜欢大开脑洞的一个坏处就在于，他经常想出一些假算法。

{{ s('description') }}

最近 Shimpme 对排序算法，尤其是冒泡排序，产生了浓厚的兴趣。为了问题简单，Shimpme 只研究对**长度为 $n$ 的排列**的冒泡排序。

我们都知道，冒泡排序的交换次数是逆序对个数。

但是，Shimpme 同学脑洞大开，他发现排序本质上就是数字的移动，因此排序的交换次数应当可以用数字移动的总距离来描述。对于第 $i$ 个位置，假设在初始排列中，这个位置上的数字是 $p_i$，那么我们需要将这个数字移动到第 $p_i$ 个位置上，因此我们移动的距离是 $|i - p_i|$。因此我们移动的总距离就是 $\sum_{i=1}^n |i - p_i|$，而冒泡排序每次会交换两个相邻的数字，每次交换可以使移动的总距离减少 2。因此 $\frac{1}{2}{\sum_{i=1}^{n}{|i-p_i|}}$ 应当就是冒泡排序的交换次数，也就是这个排列的逆序对数。

Shimpme 同学很兴奋，因为他发现了一种能够线性时间内求解一个排列逆序对个数的方法，**我们把这个方法叫做方法 $S$**。他把他的发现告诉了他的同学小 H。小 H 同学听到以后目瞪口呆，但是随即就给出了一个反例。在 $n=3$ 的时候，考虑排列 $3 ~~ 2~~1$, 这个排列的逆序对个数是 3，但是 $\frac{1}{2}\sum_{i=1}^{n}{|i-p_i|}$ 只有 2。

Shimpme 并没有放弃思考，他开始专注于研究长度为 $n$ 的排列中，能让方法 $S$ 计算出正确交换次数的排列。也就是满足 逆序对数$=\frac{1}{2}\sum_{i=1}^{n}{|i-p_i|}$ 的排列（在后文中，为了方便，我们把所有这样的排列叫“好”的排列）。他进一步想，这样的排列到底多不多？它们分布的密不密集？

为了测量“好”的排列的密度，Shimpme 定义 $next(p)$ 表示字典序严格大于 $p$ 的排列中，字典序最小的那个排列。并定义 $next^k(p)=next(next(next(next\cdots next(p))))$（总共复合 $k$ 次)。

Shimpme 想要对于一个给定的长度为 $n$ 的排列 $q$，计算有多少个 $k\geq 1$ 满足 $next^k(q)$ 是“好”的排列。但是他不会做，于是求助于你，希望你帮他解决这个问题，考虑到答案可能会很大，因此只需输出答案对 $998244353$ 取模的结果。

{{ s('input format') }}

{{ self.input_file() }}

输入第一行包含一个正整数 $T$，表示数据组数。

对于每组数据，第一行有一个正整数 $n$, 保证 $n \le {{ tools.hn(prob.args['n']) }}$。

接下来一行会输入 $n$ 个正整数，对应于题目描述中的 $q_i$，保证输入的是一个长度为 $n$ 的排列。

{{ s('output format') }}

{{ self.output_file() }}

输出一个整数，表示有多少个 $k\geq 1$ 满足 $next^k(q)$ 是“好”的排列。

输出答案对 998244353 取模的结果。

{{ s('sample', 1) }}

{{ self.sample_text() }}

{{ self.title_sample_description() }}

字典序比 $1~~3~~2$ 大的排列中，除了 $3~~2~~1$ 以外都是“好”的排列，故答案为 3。

{{ s('sample', 2) }}

{{ self.sample_text() }}

{{ s('sample', 3) }}

{{ self.sample_file() }}

{{ s('subtasks') }}

下面是对本题每个测试点的输入规模的说明。

对于所有数据，均满足 $T = 5$. 

记 $maxn$ 表示每组数据中 $n$ 的最大值，$\sum{n}$ 表示所有数据的 $n$ 的和。

{{ tbl('data') }}